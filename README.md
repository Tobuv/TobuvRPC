# Tobuv-RPC

这是一个基于netty + nacos + kyro(hessian...)实现的轻量级rpc框架。业界知名的dubbo，grpc，motan等，大家只停留在对框架的使用，这里实现一个轻量级rpc框架用于加深自己对rpc的理解，同时推动自己去读源码去学习。

## 一个基础的rpc框架

![image-20230810155218119](https://pic-typora-nb.oss-cn-hangzhou.aliyuncs.com/img/image-20230810155218119.png)

一个基础的rpc框架由三部分组成：注册中心，服务端，消费端

- 注册中心：用来保存服务的信息
- 服务端：提供服务的一端，即提供者provider
- 服务端：消费鼓舞的一端，即消费者consumer

流程：

- 服务端将服务的信息注册到注册中心，通常包括服务的地址、全类名、方法
- 客服端从注册中心获取服务的信息
- 客服端根据获得的信息，通过网络传输调用服务

## 设计

一个基本的 RPC 框架，需要包含以下部分：

1. **注册中心**：注册中心负责服务信息的注册与查找。服务端在启动的时候，扫描所有的服务，然后将自己的服务地址和服务名注册到注册中心。客户端在调用服务之前，通过注册中心查找到服务的地址，就可以通过服务的地址调用到服务啦。常见的注册中心有 `Zookeeper`、`Eureka`、`nacos` 等。
2. **动态代理**：客户端调用接口，需要框架能自己根据接口去远程调用服务，这一步是用户无感知的。这样一来，就需要使用到动态代理，用户调用接口，实际上是在调用动态生成的代理类。常见的动态代理有：`JDK Proxy`，`CGLib`，`Javassist` 等。
3. **网络传输**：RPC 远程调用实际上就是网络传输，所以网络传输是 RPC 框架中必不可少的部分。网络框架有 `Java NIO`、`Netty` 框架等。
4. **自定义协议**：网络传输需要制定好协议，一个良好的协议能提高传输的效率。
5. **序列化**：网络传输肯定会涉及到序列化，常见的序列化有`Json`、`Protostuff`、`Kyro` 等。
6. **负载均衡**：当请求调用量大的时候，需要增加服务端的数量，一旦增加，就会涉及到符合选择服务的问题，这就是负载均衡。常见的负载均衡策略有：轮询、随机、加权轮询、加权随机、一致性哈希等等。
7. **集群容错**：当请求服务异常的时候，我们是应该直接报错呢？还是重试？还是请求其他服务？这个就是集群容错策略啦。